# 网页的组成(3部分)

* 结构层(html)
* 表现层(css)
* 行为层(js)

# **程序**

为了实现某个功能或者目的，通过计算机语言写的指令序列的集合

# 一、JavaScript

* JAVA-SUN 公司发布


* JavaScript - 网景公司


* JS是由布兰登艾奇发明的

  * java是强类型的语言   js是弱类型

  * java是纯面向对象（封装、继承、多态）

    > js是基于事件和对象驱动的解释型松散型的语言（内置对象：日期、数组...）

* 执行方式

  * java是编译类型的
  * js是解释型的    ECMAscript

  > js是一种脚本语言（可以直接在浏览器中解析执行，无需编译，从上到下，没有生命周期）
  >
  > 事件驱动：对浏览器和用户的行为进行相应、
  >
  > 松散型（弱类型）：

## 1.1 作用

* 数据验证
* 实现动效
* 操作html/css
* 制作游戏
* 单页面应用（谷歌在线的word、Excel等编辑器；各大平台的云）
* 服务器端的应用（node.js）
* cookie

## 1.2 引入

````
1）引入外部文件：<script src=""></script>
注意：引入外部文件的时候，不能再标签中间写入内容
2）嵌入式： <script></script>
3）在超链接以及重定向中写入：<a href="javascript:alert(1)">超链接</a>   
4）在事件之后调用：<div onclick="alert(1)"></div>
> 注意：多个script块之间会相互影响
````

### 1.2.1 超链接的表现形式

```
  普通链接：<a href="http//:www.sxuek.com">山西优逸客</a>
  写入js代码，会屏蔽href属性： <a href="javascript:alert(1)">超链接</a>                          							<a href="javaccript:alert(0)">超链接</a>
  资源下载，默认智能是压缩过的文件属性：<a href="1.zip"></a>
  空连接，实现的是返回页面顶部<a href=""></a>
```

## 1.3 JS输出工具

* 把想要展示的数据输出至页面
* 调试

### 1.3.1 调试

```
  1、alert（）；在页面中弹出一个框。注意：alert会阻止后面代码的执行，只能输出一个
  2、console.log();将数据内容输出至控制台
  3、document.write('<div style="color:red;">html</div>')将数据内容输出至页面中注意：识别标签和行内样式
  4、confirm（0）;在页面中弹出一个带确定和取消按钮的弹出框
  5、prompt('请输入你的姓名')在页面中弹出一个带提示信息和输入框的弹出框。输出类型为string
```

### 1.3.2 命名规范

1) 变量名必须以字母、下划线_或$符号开头，后面部分可以跟任意字母、数字、_、或者$符号链接

2）不能使用更关键字（JS自定义的var）或者是保留字（为以后拓展名用）命名

3）javaScript有自己的命名规范

* 驼峰命名法：getElementByld
* 首字母大写法

4）变量名区分大小写

5）命名一定要有意义提高代码可读性

## 1.4变量

变量就是保存数据的容器

内存就是一个盒子，每次声明一个变量，它都会在内存中开辟一段空间进行保存。保存起来后，当我们需要用的时候回村内存中获取相应的数据。如果浏览器关闭，内存会释放空间，方便下次使用。

### 1.4.1 变量声明

* var
* let(es6)
* const(es6)

### 1.4.2 变量的赋值情况

* 声明变量的同时进行赋值
* 先声明，再赋值
* 声明多个变量，并且同时进行赋值
  * 注意：多个变量之间用逗号隔开

### 1.4.3 undefined 

* 变量声明之前进行调用，会返回undefined(未赋值)
* 不通过关键字声明的变量，但是赋值了它会返回对应的值（全局变量）。
* 不通过关键字声明的变量，不赋值会报错！
* 对变量重新赋值，会发生覆盖！

### 1.4.4 let 的用法

* let的用法类似于var
* let不存在变量提升现象
* let不能重新声明并赋值，报错该变量已经存在。

### 1.5.5 const的用法

* const声明的是一个常量
* const只能在声明的同时赋值
* const不存在变量提升现象
* const不能重新声明并赋值，报错该变量已经存在。

> let存在块级作用域：es6 if switch function for

## 1.5 数据类型

能够表达或者操作值得类型，称为数据类型

### 1.5.1  为何划分数据类型

* 需求不同
* 在内存中的存储位置不一样

### 1.5.2 数据类型

#### 1）基础数据类型(存放在栈区)

```
- unidentified
  - 声明变量未赋值会返回unidentified
  - 声明变量之前进行访问，返回unidentified
- null(空，占位符)
  - 可能的值是null
  - 返回的值 null
  - 返回值的类型是：object
- number(数值类型)
  - 整型、
  - 浮点型、
  - 二进制()、
  - 八进制、
  - 十进制、
  - 十六进制、
  - 科学计数法(最大值、最小值)
- string(字符串数据类型)
  - 返回的值是对应的字符串
  - 返回值的类型是string
- boolean 布尔类型值
- symbol(es6
```

#### 2）引用数据类型

* object(数组、函数....)

# 二、运算符

## 2.1 算数运算符

> +、-、*、/、++、--、%

### 2.1.1  + :  进行加法运算

* 如果两个操作数都是number，最终得到number
* 如果其中一个操作数是undefined，那么得到的结果是NAN(not a number，是number类型的一个状态)
* 如果其中一个数是null，最终得到number的值
* 如果其中搞一个操作数是Boolean，会转换成对应的值再进行计算
* 如果操作数中有一个是string，那么就会将字符串和数值连接组成字符串

### 2.1.2   -：进行减法计算

* 如果连个操作数都是number，会最终得到number
* 如果其中一个操作舒适undefined,最终得到的结果是NAN(not a number，是number类型的一个状态)
* 如果其中一个数是null，最终得到number的值
* 如果其中搞一个操作数是Boolean，会转换成对应的值再进行计算
* 如果其中有一个数是string
  * 数值：隐式转换成数值类型并进行计算
  * 字母：NAN
* 如果两个操作数都是字符串，得到NAN

### 2.1.3   * ： 进行乘法运算

* 特殊用法：** 进行幂运算

### 2.1.4  ++ ：自增     - -  :自减

* num++  先运行，再自增
* ++num  先自增，在运行

## 2.2  比较运算符

> < 、 > 、 = 、== 、=== 、 >= 、 <= 、！=

```
如果操作数是字符串类型，会先进行隐式转换，转换成功再进行正常运算；转换不成功，永远返回false
```

* null== 0     false
* undefined == null     ture

## 2.3 赋值运算符

> = 、 += 、-= 、*= 、/= 、%=

## 2.4 逻辑运算符

> &&  、 || 、  !	

可以操作任何类型的数据

数字0 、undefined、null，NAN，空字符串会转换为false

### 2.4.1  逻辑与&&

> 同真为真，其余全部为假

| num1  | num2  | result | 返回值  |
| ----- | ----- | ------ | ---- |
| true  | true  | true   | num2 |
| true  | false | false  | num2 |
| false | ture  | false  | num1 |
| false | false | false  | num1 |

* 如果第一个操作数为假，发生短路原则，对第二个数不进行操作，并返回假值

### 2.4.1 逻辑或||

> 同假为假，其余全为真

| num1  | num2  | result | 结果   |
| ----- | ----- | ------ | ---- |
| true  | true  | true   | num1 |
| true  | false | true   | num1 |
| false | true  | true   | num2 |
| false | false | false  | num2 |

## 2.5 其他运算符

### 2.5.1 一元运算符

> typeof 、++  、-- 、 + (正号)、 - (负号)  、 delete(删除一个对象)

### 2.5.2 三元运算符

> 条件表达式？为真的值：为假的值

### 2.5.3 特殊运算符

> () : 提高优先级

### 2.5.4 模板字符串(es6)

> 方便引入变量

模板字符串要用反引号引起来，如果需要引入变量通过 ${变量名} 来引入

```
console.log(`这是num1 -- ${num1}`)
```

# 三、流程控制

## 3.1流程

* 程序代码的执行顺序

> 注意：js的执行是根据浏览器的解析从上到下，一条语句一条语句的执行，有且只有一种方式

## 3.2流程控制

> 通过规定语句让程序代码有条件的按照一定方式执行。

## 3.3 表达式

> 表达式一般是由运算符和操作数构成，且有一定的值(已经有值或者即将赋值的)。

## 3.4 语句

> 以分号为标识的为一条语句。

* 声明语句（声明一个变量、数组.....)


* 赋值语句（对变量进行赋值）
* if语句，switch语句，for语句
* 函数

## 3.5 三大流程控制

### 3.5.1、顺序结构

> 是程序中最基本的流程控制。默认从上到下，一条语句一条语句执行。

### 3.5.2、选择结构

#### 3.5.2.1 分支结构

```
if(条件){
  循环体
  注意：条件可以是表达式也可以是任何数据类型
}else{
  循环体
}
```

```
if(条件){
  循环体
  注意：条件可以是表达式也可以是任何数据类型
}else if (条件){
  循环体
}else{
  
}
```

#### 3.5.2.2 条件结构

```
switch(变量){
  case 条件1 ：执行的语句（循环体）;
  break;
  case 条件1 ：执行的语句（循环体）;
  break;
  ……
  default：条件都不满足时执行的语句;
}
```

## 3.5.3  whlie语句

```
while(条件表达式){
  要执行的语句
}
```

## 3.5.4 do while 语句

```
do{
  
}while(){
  
}
```

* while和do  while 的区别：
  * while:满足条件才会执行循环体
  * do while:先执行一次循环体，再进行判断
* for 和 while  什么时候用  
  * 0循环次数确定时用for 
  * 不确定时候用while

## 3.5.5 终止语句

* break：跳出循环不再进行

* continue: 跳出本次循环

  * 最好不要使用continue，用适当的语句来替换continue

* 一次跳出多次循环，再要跳出的那层循环前面加一个标记

  ```
  out:for(){
    break out;
  }
  ```


# 四、数组

> 变量：存储数据的容器
>
> 数据：存储多条数据的容器

## 4.1 优势

* 方便对数据进行管理
* 可以保存大批量的数据

## 4.2 创建方式

```
var arr = [];
1）json格式创建数组
注意：1.数组的默认值为空
	 2.数组元素的长度是可变化的
	 3.数组可以保存任何类型的数据
2)通过实例化对象的方式
  var arr = new Array();
```

### 4.2.1赋值情况

```
1.先声明再赋值
var arr = [1,2,3,4,5,6];
2.声明之后进行赋值
var arr = [];
arr[0] = 1;
arr[1] = 2;
```

## 4.3 对数组的访问	

* 以下标的形式进行访问
  * length属性：统计数组的长度。
  * 访问数组的第一个元素：arr[0]
  * 访问数组的最后一个元素：arr[arr.length-1]
    * 注意：数组的下标是从0开始的
* 0表示数组的第一个元素，最后一个元素可以用arr.length-1来访问。如果下标的范围超过数组定义的范围返回undefined

## 4.4 对数组的遍历

> 1）for

```
for (var i = 0 ; i<arr.length ; i++){
	初始化值；条件表达式；步径值
  console.log(arr[i])
}
```

> 2）for in

```
for(变量 in 对象){
  
}
for in 最终遍历出来的是对象的属性
```

## 4.5 二维数组

每个数租元素的值对应的又是一个数组

### 4.5.1 二维数组的遍历

双层for循环来遍历

### 4.5.2 二维数组的访问

通过双下标 来访问

### 4.5.3 浅拷贝和深拷贝

> 浅拷贝：传的是地址，会改变值
>
> 指向的是赋值对象的引用



> 深拷贝：传的是值
>
> 值不会改变，指向的是赋值对象所有引用对象的全部赋值（引用）

# 五、函数

定义：将能实现某一功能的代码块封装起来，方便重复使用

特点：程序会更加简洁，维护起来会更容易

## 5.1 函数的声明方式

```
1)  通过关键字来声明
functiong 函数名([参数1],[参数2],[参数3]){
  	函数体
}

2) 通过字面量的方式
var 变量名 = function(){
  	函数体
}

3）通过实例化的方式
var 变量名 = new Function();
```

## 5.2 函数调用

1）函数名/变量名();

2)  函数自调用

> 注意；函数自调用的时候，无论之前写的是什么，必须加封号。

3）在事件之后调用只需要写函数名

## 5.3 注意

* 函数名重复会发生覆盖
* 通过关键字声明的函数，可以再声明之前进行访问(预解析)
* 通过字面量声明的函数只有在解析到它的时候才会进行赋值
* 代码是从上倒下一条语句一条语句解析执行的。多个script块之间由于解析环境一样，他们之间互相影响，调用不同块儿之间函数需要注意先声明再调用。

## 5.4 参数

> 参数：动态改变函数体内相对应变量的类型与值，使同一函数体呈现不同的效果。

```
形参：声明函数时()里传的是形式参数
实参：调用时候()里传的是实际参数
```

### 5.4.1 关于参数的个数

* 实参和形参一一对应
* 实参个数小于形参：多余的形参返回undefined
* 实参个数大于形参：只返回形参相对应的值

#### 5.4.1.1 多余实参的接收

* reset参数
  * reset接收剩余参数的时候，作为一个数组处理

```
function 函数名 ([参数1],[参数2],[参数3]...reset){
	console.log(num,num1,num2,...reset);
};
```

* arguments对象
  * 当我们创建一个函数时，默认会创建一个arguments对象
  * arguments.callee()指向函数自身

```
function 函数名 (num,num1){
  console.log(num,num1,arguments[1],arguments[2]...)
}
```

## 5.5 默认参数

1）直接在形参后面进行设置

> 注意：默认参数位置一定放在最后

2）通过三元运算符

> 条件表达式?为真的值:为假的值

3）逻辑或

> num= num||30;

## 5.6 函数的返回值

* return
  * 在函数调用的地方返回一个值	
    * 注意：如果函数没有值，会返回undefined
    * return只能返回一个值，如果在return后跟多个值会发生覆盖，最终会返回最后一个值
  * 终止函数执行
  * 一个函数里可以有多条返回语句，但是只执行一条

## 5.7 作用域

### 5.7.1环境

1）宿主环境：浏览器

2）执行环境：决定了变量和函数的访问权限

* 全局环境
* 函数环境

### 5.7.2 作用域

作用域：有关变量和函数的访问范围

* 作用域中分为全局变量和局部变量

  * 全局作用域：在任何地方都可以访问的变量

    * 在函数外部声明的变量
    * 没有通过关键字声明的变量并且同时赋值
    * window对象拥有全局作用域
    * 在函数之外通过var声明的变量
    * 没有通过关键字声明的变量并且同时赋值

  * 局部作用域：

    * 在规定的代码块内能访问的变量

      ​

### 5.7.3作用域链

在函数中存在作用域链，

当函数在运行的时候，会自动的创建一个集合，来保存可见范围内所有的变量，这个集合就是作用域链，

### 5.7.4 闭包

函数中存在作用域链，函数中的变量全部保存在作用域链中，对于这样的特性我们称之为闭包。

在函数里面再嵌套一个函数，当我们调用这个函数是形成了闭包。

#### 5.7.4.1 闭包的作用

1）保存局部变量

2）在函数外部访问局部变量

## 5.8 回调函数

把一个函数的指针(直接写函数名)作为参数传递给另一个函数，这个函数就叫做回调函数

传参方式：

1、通过函数的指针

2、把整个函数传进去

## 5.9 递归函数

在函数内部直接调用自己或者间接调用自己

## 5.10 模拟函数重载

函数重载：同一个函数因为传入的参数的类型或者个数不同，可以对应多个函数的实现，而且每种实现对应一个函数体

重载函数常用来实现功能类似而所处理的数据类型不同的问题

## 5.11 预解析顺序

1） 按照<script></script>块来解析，有多个<script></script>对时，按块解析，先解析第一个<script></script>中的代码

2）按环境来解析

3） 遇到关键字 var 和 function时（即以关键字创建的函数），提前解析到内存中（相对应的环境里）。即可声明前调用

4）若还有<script></script>，在按照上面的解析顺序进行解析。

## 5.12 内置顶层函数

所谓内置顶层函数就是，ECMAScript自带的函数.

顶层：页面中任何地方都可以使用

#### 5.12.1 escape():对字符串进行编码

* 对非字母、数字、特殊标点符号（@、+、-、/、*、。）的字符串进行编码，最终得到十六进制的转义字符序列。也就是将机器不识别的编码方式编译成机器可以识别的


#### 5.12.2unescape(str):对编码的字符串解码

* 有关数据类型转换的

#### 5.12.3 Number()：

* 将任何数据类型转换成数值类型
    * 如果是布尔值true为1，false为0；
    * 如果是数值，转换为本身，会将无意义的后导零与前导零去掉；
    * 如果是null，转换为0
    * 如果是undefined，转换为NAN not a number
    * 如果是字符串
      * 如果字符串中只有数字，则转换为数字(10进制)会忽略前导零和后导零
      * 如果是规范的浮点数，则转换为浮点数 会忽略前导零和后导零
      * 如果是空字符串，转为0
      * 如果是其他值转换为NAN

#### 5.12.4 parseint():

* 将任何数据类型转换为整数
    * 如果一个字符串中只包含数字，转换为十进制数；
    * 如果有多个空格，回先找到第一个非空的值进行转换，知道非数值时结束；
    * 如果第一个值不是一数字、空格开头的一定转换为NAN
    * 有两个参数时，第一个参数表示要转换的值，第二个参数表示几进制，返回值是一个十进制的数字；
    * 注意：第一个参数从最高位开始计算，只要有一位数可以识别为第二个参数传入的限制，则可以实现转化
    * 注意：第二个参数可以传入的值为2-36

#### 5.12.5 Float():

* 将任何数据类型转化为浮点数并返回
* 只有一个点起作用，其它无效
    * 如果字符串是一个有效的整数，它返回的是整数，不会返回浮点数

#### 5.12.6 String():

* 将任何数据类型转换为字符串
    * 如果是null，undefined,转换为字符串"null"、"undefined";
    * 如果是数值类型，转换为本身的字符串，123转换为“123”
    * 如果是布尔类型，true转换为“true”，false转换成"false"

#### 5.12.7 Boolean():

* 把任何数据类型转换为布尔型
* 转换为假："" 、 null  、 undefined 、 0 、false、 NAN；
    * 其他都为真

#### 5.12.8 isNaN():

* 判断一个数是否能转换为数值
* 如果能转换成数值返回假，不能返回为真

#### 5.12.9 eval():

* 将符合js语法常规规范的字符串转换成javascript命令执行(必须在一行)

#### 5.12.10 toString():

*   将对象以字符串方式来表示，都是通过对象的方式来调用的。

    *   格式：对象toString();
    *   数组  分割的字符串
    *   布尔 字符串（还是本身 ）数值类型  
    *   null与undefined没有toString方法


# 六 对象

面向过程：按照流程一步步操作

面向对象：不管中间环节具体实现，只要结果

对象： 一切皆对象，对象指的就是人们所能接触到的所有的事物，有抽象的，也有具体的

对象是属性和行为的集合

​	属性：描述对象特征的数据

​	行为：操作对象方法的数据

类：具有相同属性和行为的对象的抽象

类是对象的抽象，对象是类的实例化

## 6.1对象的声明

实例化对象	var person = New Object();

字面量	 	ar Person = {};

构造函数 	Person(){}

## 6.2 添加属性、方法

属性： 对象.属性名  =  属性值

​	     对象[‘属性名’] = 属性值；

方法： 对象.方法名 = function(){}

​	    对象['方法名'] = function(){}

## 6.3 访问属性、方法

属性： 对象.属性名

​	    对象.['属性名']

方法： 方法.属性名

​	     方法.['方法名']

## 6.4 删除属性、方法

delete

## 6.5清空对象

null

## 6.6 for in

对象： i > 属性名/方法名

​	    对象名[i]  > 属性值/方法

数组：i > 下标

## 6.7 对象封装

将对象的所有组成部分全部组合起来，并对部分细节进行隐蔽，使其受到保护，只留下和外界的接口

### 6.7.1 工厂函数:不推荐

>  构造函数首字母大写	   

特点：方便维护，节省内存。但是代码不规范

### 6.7.2 构造函数

特点：造成内存浪费

### 6.7.3 原型

原型也是一个对象。在js中，每个对象都会击沉给另一个对象的所有属性和方法，被继承的这个对象就是原型

1对象[[prototype]]

[[prototype]]是对象内部的一个属性，但是我们不能直接访问。FF和Chrome提供了'proto'访问器

ECM提供了Object.getprototype(object)访问器。指向该对象的原型

2：函数  prototype

每个函数都会有一个prototype

3：原型对象constructor

每个原型对象身上都有一个constructor对象

函数对象和原型对象通过prototype和constructor实现相互关联

通过prototype可以实现代码共享，实现继承

当一个函数作为构造函数来使用时会把该函数的prototype属性作为原型值赋给所有通过该构造函数实例化的对象的原型

### 4.7.4 构造函数结合原型

构造函数中一般放属性，原型中一般放方法

## ！CSS 3 中 Hack 问题你是怎么处理的

浏览器内核

1、Trident内核：代表作品是IE，因IE捆绑在Windows中，所以占有极高的份额，又称为IE内核或MSHTML，此内核只能用于Windows平台，且不是开源的。代表作品还有腾讯、Maxthon（遨游）、360浏览器等。

2、Gecko内核：代表作品是Firefox，即火狐浏览器。因火狐是最多的用户，故常被称为firefox内核它是开源的，最大优势是跨平台，在Microsoft Windows、Linux、MacOs X等主要操作系统中使用。

3、Webkit内核：代表作品是Safari、曾经的Chrome，是开源的项目。

4、Presto内核：代表作品是Opera，Presto是由Opera Software开发的浏览器排版引擎，它是世界公认最快的渲染速度的擎。在13年之后，Opera宣布加入谷歌阵营，弃用了Presto .

5、Blink内核：由Google和Opera Software开发的浏览器排版引擎，2013年4月发布。现在Chrome内核是Blink